<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sound Monitoring System</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" />
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2c3e50;
            --success-color: #2ecc71;
            --warning-color: #f39c12;
            --danger-color: #e74c3c;
            --light-color: #ecf0f1;
            --dark-color: #2c3e50;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            background-color: #f5f7fa;
            color: #333;
        }

        .dashboard {
            display: grid;
            grid-template-columns: 240px 1fr;
            min-height: 100vh;
        }

        /* Sidebar */
        .sidebar {
            background-color: var(--secondary-color);
            color: white;
            padding: 20px 0;
            grid-column: 1;
            position: fixed;
            width: 240px;
            height: 100vh;
            overflow-y: auto;
        }

        .sidebar-header {
            padding: 0 20px 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
        }

        .sidebar-header h1 {
            font-size: 1.2em;
            margin-bottom: 5px;
        }

        .sidebar-header p {
            font-size: 0.8em;
            color: rgba(255, 255, 255, 0.6);
        }

        .system-status {
            padding: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .status-indicator {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 10px;
        }

        .status-dot.active {
            background-color: var(--success-color);
            box-shadow: 0 0 8px var(--success-color);
        }

        .status-dot.inactive {
            background-color: var(--danger-color);
        }

        .nav-menu {
            padding: 20px 0;
        }

        .nav-item {
            padding: 10px 20px;
            display: flex;
            align-items: center;
            transition: background-color 0.3s;
            cursor: pointer;
        }

        .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .nav-item.active {
            background-color: var(--primary-color);
        }

        .nav-item i {
            margin-right: 10px;
            width: 20px;
            text-align: center;
        }

        /* Main Content */
        .main-content {
            grid-column: 2;
            padding: 20px;
        }

        .header-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #ddd;
        }

        .header-bar h2 {
            font-size: 1.5rem;
            color: var(--dark-color);
        }

        .header-actions button {
            padding: 8px 15px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 10px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .stat-card {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            padding: 20px;
            text-align: center;
            transition: transform 0.3s, box-shadow 0.3s;
            position: relative;
            overflow: hidden;
        }

        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }

        .stat-card h3 {
            font-size: 0.9rem;
            color: #888;
            margin-bottom: 10px;
        }

        .stat-card .value {
            font-size: 2rem;
            font-weight: bold;
            color: var(--dark-color);
        }

        .stat-card .icon {
            position: absolute;
            top: 15px;
            right: 15px;
            font-size: 1.2rem;
            color: rgba(0, 0, 0, 0.1);
        }

        .card {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            margin-bottom: 20px;
            overflow: hidden;
        }

        .card-header {
            padding: 15px 20px;
            background-color: var(--light-color);
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .card-body {
            padding: 20px;
        }

        /* Map */
        .map-container {
            height: 500px;
        }

        #map {
            height: 100%;
            width: 100%;
            border-radius: 8px;
        }

        /* Lists */
        .list-container {
            max-height: 400px;
            overflow-y: auto;
        }

        .detection-item, .movement-item {
            padding: 15px;
            border-bottom: 1px solid #eee;
            transition: background-color 0.3s;
        }

        .detection-item:hover, .movement-item:hover {
            background-color: #f9f9f9;
        }

        .detection-item:last-child, .movement-item:last-child {
            border-bottom: none;
        }

        .detection-type {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            margin-right: 5px;
        }

        .detection-type.drone {
            background-color: #ffcdd2;
            color: #c62828;
        }

        .detection-type.car {
            background-color: #bbdefb;
            color: #1565c0;
        }

        .detection-type.unknown {
            background-color: #e0e0e0;
            color: #616161;
        }

        .detection-info {
            margin-top: 5px;
            font-size: 0.9rem;
            color: #666;
        }

        .grid-container {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
        }

        /* For mobile */
        @media (max-width: 768px) {
            .dashboard {
                grid-template-columns: 1fr;
            }

            .sidebar {
                display: none;
                position: fixed;
                z-index: 1000;
                width: 100%;
            }

            .main-content {
                grid-column: 1;
            }

            .grid-container {
                grid-template-columns: 1fr;
            }
        }

        /* Toggle for mobile menu */
        .mobile-menu-toggle {
            display: none;
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--primary-color);
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            text-align: center;
            line-height: 50px;
            font-size: 24px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            z-index: 1001;
            cursor: pointer;
        }

        @media (max-width: 768px) {
            .mobile-menu-toggle {
                display: block;
            }
        }

        /* Flex utility */
        .d-flex {
            display: flex;
        }

        .justify-between {
            justify-content: space-between;
        }

        .align-center {
            align-items: center;
        }

        .flex-wrap {
            flex-wrap: wrap;
        }

        /* Types badge colors */
        .badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            margin: 2px;
        }

        /* Custom colors for labels */
        .badge-info {
            background-color: #e3f2fd;
            color: #0077c2;
        }
    </style>
</head>
<body>
<div class="dashboard">
    <!-- Sidebar -->
    <aside class="sidebar">
        <div class="sidebar-header">
            <h1>Sound Monitoring</h1>
            <p>Acoustic Detection System</p>
        </div>

        <div class="system-status">
            <div class="status-indicator">
                <div class="status-dot active"></div>
                <span>System Active</span>
            </div>
            <div class="status-indicator">
                <div class="status-dot active" id="sensors-status"></div>
                <span id="sensors-status-text">Sensors Online</span>
            </div>
            <div class="status-indicator">
                <div class="status-dot active" id="api-status"></div>
                <span>API Online</span>
            </div>
        </div>

        <nav class="nav-menu">
            <div class="nav-item active">
                <i class="fas fa-tachometer-alt"></i>
                <span>Dashboard</span>
            </div>
        </nav>
    </aside>

    <!-- Mobile menu toggle -->
    <div class="mobile-menu-toggle">
        <i class="fas fa-bars"></i>
    </div>

    <!-- Main content -->
    <main class="main-content">
        <div class="header-bar">
            <h2>Sound Monitoring Dashboard</h2>
            <div class="header-actions">
                <button id="refresh-btn"><i class="fas fa-sync-alt"></i> Refresh Data</button>
            </div>
        </div>

        <!-- Stats Grid -->
        <div class="stats-grid">
            <div class="stat-card">
                <i class="fas fa-microphone-alt icon"></i>
                <h3>Total Detections</h3>
                <div class="value" id="total-detections">0</div>
            </div>
            <div class="stat-card">
                <i class="fas fa-satellite-dish icon"></i>
                <h3>Active Sensors</h3>
                <div class="value" id="total-sensors">0</div>
            </div>
            <div class="stat-card">
                <i class="fas fa-route icon"></i>
                <h3>Movement Tracks</h3>
                <div class="value" id="total-movements">0</div>
            </div>
            <div class="stat-card">
                <i class="fas fa-bolt icon"></i>
                <h3>Recent Activity</h3>
                <div class="value" id="recent-activity">0</div>
            </div>
        </div>

        <!-- Detection Types Card -->
        <div class="card">
            <div class="card-header">
                <h3>Detection Types</h3>
            </div>
            <div class="card-body">
                <div id="detection-types" class="d-flex flex-wrap">
                    <!-- Detection types will be inserted here -->
                </div>
            </div>
        </div>

        <!-- Grid layout for map and lists -->
        <div class="grid-container">
            <!-- Map -->
            <div class="card">
                <div class="card-header">
                    <h3>Detection Map</h3>
                    <div class="map-controls">
                        <button id="center-map-btn" class="btn-sm">Center Map</button>
                    </div>
                </div>
                <div class="card-body map-container">
                    <div id="map"></div>
                </div>
            </div>

            <!-- Right column with detections and movements -->
            <div>
                <!-- Recent Detections -->
                <div class="card">
                    <div class="card-header">
                        <h3>Recent Detections</h3>
                    </div>
                    <div class="card-body">
                        <div class="list-container" id="detections-container">
                            <p>Loading detections...</p>
                        </div>
                    </div>
                </div>

                <!-- Movement Predictions -->
                <div class="card">
                    <div class="card-header">
                        <h3>Movement Predictions</h3>
                    </div>
                    <div class="card-body">
                        <div class="list-container" id="movements-container">
                            <p>Loading movement predictions...</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.js"></script>
<script>
    // Default map center (Kyiv coordinates)
    const defaultCenter = [50.4501, 30.5234];

    // Initialize map
    let map = L.map('map').setView(defaultCenter, 10);

    // Add tile layer
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);

    // Markers for sensors and detections
    let sensorMarkers = {};
    let detectionMarkers = {};
    let predictionMarkers = {};

    // Map all sensors layer group
    let sensorsLayer = L.layerGroup().addTo(map);
    let detectionsLayer = L.layerGroup().addTo(map);
    let predictionsLayer = L.layerGroup().addTo(map);

    // DOM elements
    const refreshBtn = document.getElementById('refresh-btn');
    const centerMapBtn = document.getElementById('center-map-btn');
    const mobileMenuToggle = document.querySelector('.mobile-menu-toggle');
    const sidebar = document.querySelector('.sidebar');

    // Mobile menu toggle
    mobileMenuToggle.addEventListener('click', () => {
        if (sidebar.style.display === 'block') {
            sidebar.style.display = 'none';
        } else {
            sidebar.style.display = 'block';
        }
    });

    // Center map button
    centerMapBtn.addEventListener('click', () => {
        map.setView(defaultCenter, 10);
    });

    // Refresh button
    refreshBtn.addEventListener('click', () => {
        refreshData();
    });

    // Fetch system statistics
    function fetchStatistics() {
        fetch('/api/stats')
            .then(response => response.json())
            .then(data => {
                // Update stats
                document.getElementById('total-detections').textContent = data.total_detections;
                document.getElementById('total-sensors').textContent = data.total_sensors;
                document.getElementById('total-movements').textContent = data.total_movements;
                document.getElementById('recent-activity').textContent = data.recent_activity;

                // Update sensor status indicator
                if (data.total_sensors > 0) {
                    document.getElementById('sensors-status').classList.add('active');
                    document.getElementById('sensors-status').classList.remove('inactive');
                    document.getElementById('sensors-status-text').textContent = `${data.total_sensors} Sensors Online`;
                } else {
                    document.getElementById('sensors-status').classList.remove('active');
                    document.getElementById('sensors-status').classList.add('inactive');
                    document.getElementById('sensors-status-text').textContent = 'No Sensors Online';
                }

                // Update detection types
                const typesContainer = document.getElementById('detection-types');
                typesContainer.innerHTML = '';

                if (Object.keys(data.detection_types).length === 0) {
                    typesContainer.innerHTML = '<p>No detections yet.</p>';
                } else {
                    for (const [type, count] of Object.entries(data.detection_types)) {
                        const badge = document.createElement('div');
                        badge.className = 'badge badge-info';
                        badge.textContent = `${type}: ${count}`;
                        typesContainer.appendChild(badge);
                    }
                }
            })
            .catch(error => {
                console.error('Error fetching statistics:', error);
            });
    }

    // Fetch sensors and add to map
    function fetchSensors() {
        fetch('/api/sensors')
            .then(response => response.json())
            .then(data => {
                // Clear existing sensors layer
                sensorsLayer.clearLayers();

                data.forEach(sensor => {
                    // Create sensor marker
                    const marker = L.circleMarker([sensor.latitude, sensor.longitude], {
                        radius: 5,
                        fillColor: '#3498db',
                        color: '#2980b9',
                        weight: 1,
                        opacity: 1,
                        fillOpacity: 0.8
                    });

                    // Add popup
                    const lastActiveDate = new Date(sensor.last_active * 1000);
                    marker.bindPopup(`
                            <strong>Sensor ID:</strong> ${sensor.id}<br>
                            <strong>Location:</strong> ${sensor.latitude.toFixed(5)}, ${sensor.longitude.toFixed(5)}<br>
                            <strong>Altitude:</strong> ${sensor.altitude.toFixed(1)}m<br>
                            <strong>Last Active:</strong> ${lastActiveDate.toLocaleString()}
                        `);

                    // Add to sensors layer
                    marker.addTo(sensorsLayer);
                    sensorMarkers[sensor.id] = marker;
                });
            })
            .catch(error => {
                console.error('Error fetching sensors:', error);
            });
    }

    // Fetch and display recent detections
    function fetchDetections() {
        fetch('/api/detections?limit=10')
            .then(response => response.json())
            .then(data => {
                // Update detections list
                const detectionsContainer = document.getElementById('detections-container');

                if (data.length === 0) {
                    detectionsContainer.innerHTML = '<p>No detections yet.</p>';
                } else {
                    let html = '';

                    data.forEach(detection => {
                        const date = new Date(detection.timestamp * 1000);
                        html += `
                                <div class="detection-item">
                                    <span class="detection-type ${detection.detection.type.toLowerCase()}">${detection.detection.type}</span>
                                    <span>${(detection.detection.confidence * 100).toFixed(1)}%</span>
                                    <div class="detection-info">
                                        <div>Sensor: ${detection.sensor_id}</div>
                                        <div>Time: ${date.toLocaleString()}</div>
                                        <div>Amplitude: ${detection.detection.amplitude.toFixed(1)} dB</div>
                                    </div>
                                </div>
                            `;

                        // Add marker to map
                        addDetectionMarker(detection);
                    });

                    detectionsContainer.innerHTML = html;
                }
            })
            .catch(error => {
                console.error('Error fetching detections:', error);
            });
    }

    // Fetch and display movement predictions
    function fetchMovements() {
        fetch('/api/movements?limit=10')
            .then(response => response.json())
            .then(data => {
                // Update movements list
                const movementsContainer = document.getElementById('movements-container');

                if (data.length === 0) {
                    movementsContainer.innerHTML = '<p>No movement predictions yet.</p>';
                } else {
                    let html = '';

                    data.forEach(movement => {
                        const sourceDate = new Date(movement.source.timestamp * 1000);
                        const predictionDate = new Date(movement.prediction.timestamp * 1000);

                        html += `
                                <div class="movement-item">
                                    <span class="detection-type ${movement.source.type.toLowerCase()}">${movement.source.type}</span>
                                    <div class="detection-info">
                                        <div>Speed: ${movement.speed_kmh.toFixed(1)} km/h</div>
                                        <div>Direction: ${movement.direction.toFixed(1)}°</div>
                                        <div>From: ${sourceDate.toLocaleString()}</div>
                                        <div>Predicted at: ${predictionDate.toLocaleString()}</div>
                                    </div>
                                </div>
                            `;

                        // Add prediction marker and path to map
                        addPredictionMarker(movement);
                    });

                    movementsContainer.innerHTML = html;
                }
            })
            .catch(error => {
                console.error('Error fetching movements:', error);
            });
    }

    // Add a detection marker to the map
    function addDetectionMarker(detection) {
        // Create marker
        const marker = L.circleMarker([detection.location.latitude, detection.location.longitude], {
            radius: 8,
            fillColor: getColorForType(detection.detection.type),
            color: '#000',
            weight: 1,
            opacity: 1,
            fillOpacity: 0.8
        });

        // Add popup
        const date = new Date(detection.timestamp * 1000);
        marker.bindPopup(`
                <strong>${detection.detection.type}</strong><br>
                Confidence: ${(detection.detection.confidence * 100).toFixed(1)}%<br>
                Time: ${date.toLocaleString()}<br>
                Sensor: ${detection.sensor_id}
            `);

        // Add to detections layer
        marker.addTo(detectionsLayer);

        // Store reference (with expiration)
        if (detectionMarkers[detection.id]) {
            detectionsLayer.removeLayer(detectionMarkers[detection.id]);
        }
        detectionMarkers[detection.id] = marker;

        // Remove old markers if there are too many
        const maxMarkers = 50;
        const markerIds = Object.keys(detectionMarkers);
        if (markerIds.length > maxMarkers) {
            // Remove oldest markers
            const markersToRemove = markerIds.slice(0, markerIds.length - maxMarkers);
            markersToRemove.forEach(id => {
                if (detectionMarkers[id]) {
                    detectionsLayer.removeLayer(detectionMarkers[id]);
                    delete detectionMarkers[id];
                }
            });
        }
    }

    // Add a prediction marker and path to the map
    function addPredictionMarker(movement) {
        // Create source point
        const sourcePoint = [movement.source.latitude, movement.source.longitude];

        // Create prediction point
        const predictionPoint = [movement.prediction.latitude, movement.prediction.longitude];

        // Create path between points
        const path = L.polyline([sourcePoint, predictionPoint], {
            color: getColorForType(movement.source.type),
            weight: 2,
            opacity: 0.7,
            dashArray: '5, 5'
        });

        // Create marker for prediction
        const marker = L.circleMarker(predictionPoint, {
            radius: 8,
            fillColor: getColorForType(movement.source.type),
            color: '#000',
            weight: 1,
            opacity: 0.7,
            fillOpacity: 0.5
        });

        // Add popup
        const predictionDate = new Date(movement.prediction.timestamp * 1000);
        marker.bindPopup(`
                <strong>Predicted ${movement.source.type}</strong><br>
                Speed: ${movement.speed_kmh.toFixed(1)} km/h<br>
                Direction: ${movement.direction.toFixed(1)}°<br>
                Predicted arrival: ${predictionDate.toLocaleString()}
            `);

        // Add to predictions layer
        path.addTo(predictionsLayer);
        marker.addTo(predictionsLayer);

        // Store references (with expiration)
        if (predictionMarkers[movement.id]) {
            if (predictionMarkers[movement.id].marker) {
                predictionsLayer.removeLayer(predictionMarkers[movement.id].marker);
            }
            if (predictionMarkers[movement.id].path) {
                predictionsLayer.removeLayer(predictionMarkers[movement.id].path);
            }
        }

        predictionMarkers[movement.id] = {
            marker: marker,
            path: path
        };

        // Remove old markers if there are too many
        const maxPredictions = 20;
        const predictionIds = Object.keys(predictionMarkers);
        if (predictionIds.length > maxPredictions) {
            // Remove oldest predictions
            const predictionsToRemove = predictionIds.slice(0, predictionIds.length - maxPredictions);
            predictionsToRemove.forEach(id => {
                if (predictionMarkers[id]) {
                    if (predictionMarkers[id].marker) {
                        predictionsLayer.removeLayer(predictionMarkers[id].marker);
                    }
                    if (predictionMarkers[id].path) {
                        predictionsLayer.removeLayer(predictionMarkers[id].path);
                    }
                    delete predictionMarkers[id];
                }
            });
        }
    }

    // Get color based on detection type
    function getColorForType(type) {
        const colors = {
            'drone': '#e74c3c',  // Red
            'car': '#3498db',   // Blue
            'unknown': '#95a5a6' // Gray
        };

        return colors[type.toLowerCase()] || '#95a5a6';
    }

    // Refresh all data
    function refreshData() {
        fetchStatistics();
        fetchSensors();
        fetchDetections();
        fetchMovements();
    }

    // Initial data load
    refreshData();

    // Auto refresh data every 10 seconds
    const refreshInterval = setInterval(refreshData, 10000);
</script>
</body>
</html>